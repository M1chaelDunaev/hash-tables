
*Сравнение производилось между классами HashMap<size_t, size_t> и std::unordered_map<size_t, size_t> с 10 000 000 элементов
*Процессор: Intel Core i5-10400f Система: Windows 10
*Полный код бенчмарков находится в файле HashTableBenchmarks.h

Вставка(insert)__________________________________________________________________________________________________________________

Описание алгоритма:

    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Также у обоих хеш-таблиц вызывается метод reserve(10 000 000)

    После запуска таймера: Запускается цикл for(auto& elem : v); На каждой его итерации у хеш-таблицы вызывается метод insert(elem)

Результат:

	Алгоритм выполнялся 10 раз. Среднее время выполнения у HashMap составило 3937.7 ms, у std::unordered_map 7657.4 ms
	Таким образом можно говорить, что вставка в HashMap выполняется на 94% (в 1.94 раза) быстрее

Поиск(find)______________________________________________________________________________________________________________________

Описание алгоритма:
    
    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Содержимое вектора вставляется в обе хеш-таблицы.Также создается 
    вектор iv типа std::vector<size_t> со значениями от 0 до 9 999 999(индексы для v), расположенными в рандомном порядке. Также создаются 
    две переменные: size_t resCount1 = 0; size_t resCount2 = 0; Они будут хранить количество найденных элементов

    После запуска таймера: Запускается цикл for(auto elem : iv); На каждой его итерации у хеш-таблицы вызывается метод find(v[elem].first),
    а возвращаемый итератор сравнивается с end(), в случае, когда они не равны инкрементируется соответствующий resCount

Результат:

    Алгоритм выполнялся 10 раз. Среднее время выполнения у HashMap составило 3966.3 ms, у std::unordered_map 8382.2 ms
	Таким образом можно говорить, что поиск в HashMap выполняется на 111% (в 2.11 раза) быстрее

Удаление(erase)__________________________________________________________________________________________________________________

Описание алгоритма:
    
    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Содержимое вектора вставляется в обе хеш-таблицы. Также создается 
    вектор iv типа std::vector<size_t> со значениями от 0 до 9 999 999(индексы для v), расположенными в рандомном порядке. Также создаются 
    две переменные: size_t resCount1 = 0; size_t resCount2 = 0; Они будут хранить количество удаленных элементов

    После запуска таймера: Запускается цикл for(auto elem : iv); На каждой его итерации у хеш-таблицы вызывается метод erase(v[elem].first),
    а возвращаемое значение прибавляется к соответствующему resCount 

Результат:

    Алгоритм выполнялся 10 раз. Среднее время выполнения у HashMap составило 7142.6 ms, у std::unordered_map 8536.8 ms
    Таким образом можно говорить, что удаление в HashMap выполняется на 20% (в 1.2 раза) быстрее

Прямая итерация__________________________________________________________________________________________________________________

Описание алгоритма:

    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Содержимое вектора вставляется в обе хеш-таблицы(m1 и m2).
    Также создаются две переменные: size_t resCount1 = 0; size_t resCount2 = 0; Они будут хранить общую сумму ключей, 
    посещенных во время итерации элементов

    После запуска таймера: Запускается цикл for(auto& elem : m1(или m2)); На каждой его итерации, к соответствующему resCount
    прибавляется elem.first

Результат:

    Алгоритм выполнялся 10 раз. Среднее время выполнения у HashMap составило 1254.5 ms, у std::unordered_map 608.2 ms
    Таким образом можно говорить, что прямая итерация в HashMap выполняется на 106% (в 2.06 раза) медленнее

Обратная итерация________________________________________________________________________________________________________________

Описание алгоритма:

    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Содержимое вектора вставляется в обе хеш-таблицы(m1 и m2).
    Также создаются две переменные: size_t resCount1 = 0; size_t resCount2 = 0; Они будут хранить общую сумму ключей,
    посещенных во время итерации элементов

    После запуска таймера: Запускается цикл for (auto it = m1.back(); !it.isBeforeBegin(); --it)(Для HashMap) или 
    for (auto it = (--(m2.end())); it != m2.begin(); --it)(для std::unordered_map). На каждой его итерации, к соответствующему resCount 
    прибавляется it->first

Результат:

    Алгоритм выполнялся 10 раз. Среднее время выполнения у HashMap составило 1262.1 ms, у std::unordered_map 2003.8 ms
    Таким образом можно говорить, что обратная итерация в HashMap выполняется на 59% (в 1.59 раза) быстрее
